import os
import json
import time

# Use home directory for reliable permissions on Raspberry Pi
HOME_DIR = os.path.expanduser('~')
CONFIG_DIR = os.path.join(HOME_DIR, '.pump_control')
CONFIG_FILE = os.path.join(CONFIG_DIR, 'pump_config.json')

# Create config directory if it doesn't exist
os.makedirs(CONFIG_DIR, exist_ok=True)

# GPIO Pin Definitions
WELL_PUMP = 17
DIST_PUMP = 18
SUMMER_HIGH = 22
SUMMER_LOW = 23
SUMMER_EMPTY = 24
WINTER_HIGH = 26
WINTER_LOW = 27

# System Modes
MODES = {
    'SUMMER': 'Summer Mode',
    'WINTER': 'Winter Mode',
    'CHANGEOVER': 'Changeover Mode'
}

# Default Configuration
DEFAULT_CONFIG = {
    'current_mode': 'SUMMER',
    'pump_settings': {
        'well_pump_gpm': 40.0,
        'dist_pump_gpm': 15.0
    }
}


class ConfigManager:
    _config_cache = None

    @staticmethod
    def load_config():
        """Load configuration from file with retries"""
        max_retries = 3
        retry_delay = 1  # seconds

        for attempt in range(max_retries):
            try:
                # Use cached config if available
                if ConfigManager._config_cache is not None:
                    return ConfigManager._config_cache

                if os.path.exists(CONFIG_FILE):
                    with open(CONFIG_FILE, 'r') as f:
                        config = json.load(f)
                    print(f"Loaded config from {CONFIG_FILE}: {config}")
                    ConfigManager._config_cache = config
                    return config
                else:
                    print(f"Config file not found at {CONFIG_FILE}, creating with defaults")
                    default_config = DEFAULT_CONFIG.copy()
                    ConfigManager.save_config(default_config)
                    return default_config
            except (json.JSONDecodeError, IOError) as e:
                if attempt < max_retries - 1:
                    print(f"Error loading config (attempt {attempt + 1}): {e}")
                    time.sleep(retry_delay)
                else:
                    print(f"Failed to load config after {max_retries} attempts: {e}")
                    return DEFAULT_CONFIG.copy()

    @staticmethod
    def save_config(config):
        """Save configuration to file with verification"""
        max_retries = 3
        retry_delay = 1  # seconds
        temp_file = f"{CONFIG_FILE}.tmp"

        for attempt in range(max_retries):
            try:
                # First write to temporary file
                with open(temp_file, 'w') as f:
                    json.dump(config, f, indent=4)

                # Verify the temporary file
                with open(temp_file, 'r') as f:
                    saved_config = json.load(f)

                if saved_config != config:
                    raise ValueError("Config verification failed")

                # If verification passes, rename temp file to actual config file
                os.replace(temp_file, CONFIG_FILE)

                # Verify the final file
                with open(CONFIG_FILE, 'r') as f:
                    final_config = json.load(f)

                if final_config != config:
                    raise ValueError("Final config verification failed")

                # Update cache with new config
                ConfigManager._config_cache = config
                print(f"Config saved and verified successfully: {config}")
                return True

            except Exception as e:
                if attempt < max_retries - 1:
                    print(f"Error saving config (attempt {attempt + 1}): {e}")
                    time.sleep(retry_delay)
                else:
                    print(f"Failed to save config after {max_retries} attempts: {e}")
                    if os.path.exists(temp_file):
                        try:
                            os.remove(temp_file)
                        except:
                            pass
                    raise

    @staticmethod
    def reload_config():
        """Force reload of config from disk"""
        ConfigManager._config_cache = None
        return ConfigManager.load_config()

    @staticmethod
    def get_config_path():
        """Get the current config file path"""
        return CONFIG_FILE


# Initialize config file if it doesn't exist
if not os.path.exists(CONFIG_FILE):
    try:
        ConfigManager.save_config(DEFAULT_CONFIG)
    except Exception as e:
        print(f"Error creating initial config file: {e}")